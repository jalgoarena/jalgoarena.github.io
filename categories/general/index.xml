<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>General on JAlgoArena Home</title>
    <link>https://jalgoarena.github.io/categories/general/</link>
    <description>Recent content in General on JAlgoArena Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 28 Aug 2018 09:07:09 +0200</lastBuildDate>
    
	<atom:link href="https://jalgoarena.github.io/categories/general/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Redesign Submissions (Part 1)</title>
      <link>https://jalgoarena.github.io/blog/redesign-submissions/</link>
      <pubDate>Tue, 28 Aug 2018 09:07:09 +0200</pubDate>
      
      <guid>https://jalgoarena.github.io/blog/redesign-submissions/</guid>
      <description>Submissions flow Submissions flow within JAlgoArena was already re-designed few times, mostly I was focusing on improvements around chosen technology.
The major upgrade happen when submission flow has changed from synchronous highly coupled design to asynchronous based on apache kafka with decoupled components.
Now I would like to stop and rethink all of that, in technology agnostic way. The approach I want to choose is strictly based on requirements, then modeling messages - the only way to communicate in a new submissions world.</description>
    </item>
    
    <item>
      <title>Road to Cockroach DB</title>
      <link>https://jalgoarena.github.io/blog/road-to-cockroachdb/</link>
      <pubDate>Tue, 07 Aug 2018 06:26:36 +0200</pubDate>
      
      <guid>https://jalgoarena.github.io/blog/road-to-cockroachdb/</guid>
      <description>Intro To fully understand all words used across article - please refer to domain page.
Databases in microservices world Databases &amp;hellip; yes databases. In new microservice architecture world so much impact is put on serverless or function style components, where stateless code wins. And obviously that&amp;rsquo;s a great idea, when you have no state you have no need to synchronize nor to lock. Scaling is the matter of replication and understanding of flow is obvious in a immutable world.</description>
    </item>
    
    <item>
      <title>Continuous Delivery</title>
      <link>https://jalgoarena.github.io/blog/continuous-delivery/</link>
      <pubDate>Wed, 25 Jul 2018 07:42:36 +0200</pubDate>
      
      <guid>https://jalgoarena.github.io/blog/continuous-delivery/</guid>
      <description>Key factor to JAlgoArena development – ubiquitous automation Nowadays we software engineers are in common agreement - automation is key to success an DevOps movement just proves that. The goal of developing JAlgoArena from the very beginning was to make as much of automated deployment as possible - and in this post I want to explain how does it look like.
Deployment flow  Initially, developer push his changes to GitHub In next stage, GitHub notifies Travis CI about changes Travis CI runs whole continuous integration flow, running compilation, tests and generating reports  coverage report is sent to Codecov using Gradle script builds and publishes new docker image for new tags (releases) zip package is saved to GitHub releases for new tags (releases)  Nomad jobs takes artifact and deploy/scale automatically JAlgoArena components  docker images for docker based environment zip packages for non-docker based environment   Continuous Delivery diagram Possible improvements For now there is still couple of manual steps, some of them are such by design, others where yet not replaced:</description>
    </item>
    
    <item>
      <title>Welcome to JAlgoArena</title>
      <link>https://jalgoarena.github.io/blog/welcome/</link>
      <pubDate>Fri, 20 Jul 2018 21:27:50 +0200</pubDate>
      
      <guid>https://jalgoarena.github.io/blog/welcome/</guid>
      <description>Welcome to JAlgoArena – an open source algorithmic contest platform Hi there and welcome to JAlgoArena - this is first post just to mark the start point! There is lots of interesting technical considerations which are part of building such platform - especially if you have cloud native, high availability topics as the priorities for developing such platform!
So far it was used successfully in few companies to run globally spread on-premises hosted company wide algorithmic contest - and you know what?</description>
    </item>
    
  </channel>
</rss>